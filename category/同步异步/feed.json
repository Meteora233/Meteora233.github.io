{
    "version": "https://jsonfeed.org/version/1",
    "title": "Luk's Blog • All posts by \"同步异步\" category",
    "description": "",
    "home_page_url": "https://Meteora233.github.io",
    "items": [
        {
            "id": "https://meteora233.github.io/2024/01/29/computer-science/webLearning/javascript/Promise/",
            "url": "https://meteora233.github.io/2024/01/29/computer-science/webLearning/javascript/Promise/",
            "title": "JavaSrcipt",
            "date_published": "2024-01-28T16:00:00.000Z",
            "content_html": "<h1 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h1><p>单纯代表计算机可以同时执行多项任务</p>\n<ul>\n<li>对于一个单核处理器,计算机可以使用分配时间片的方式，让一个任务执行一段时间，切换到另一个任务再执行一段时间，不同的任务会交替往复的一直执行下去。这个过程被称为进程或上下文切换。</li>\n<li>对于多核处理器，可以不同的核心上处理不同的任务，达到<strong>并行</strong>的效果</li>\n</ul>\n<h1 id=\"同步-synchronous\"><a href=\"#同步-synchronous\" class=\"headerlink\" title=\"同步 (synchronous)\"></a>同步 (synchronous)</h1><p>同步指的是必须等到前一个任务完成之后，才能执行下一个任务.在同步中没有并发的概念</p>\n<h1 id=\"异步-asynchronous\"><a href=\"#异步-asynchronous\" class=\"headerlink\" title=\"异步(asynchronous)\"></a>异步(asynchronous)</h1><p>不同任务之间不会相互等待，在执行任务 a 的时候也能执行任务 b。典型使用异步的方式是多线程编程，在多核的情况下，每个线程都会被分配到独立的核心上运行。实现真正的”并行”,单核处理器，操作系统会使用分配时间片的方式来执行线程</p>\n<h1 id=\"选择单线程与多线程\"><a href=\"#选择单线程与多线程\" class=\"headerlink\" title=\"选择单线程与多线程\"></a>选择单线程与多线程</h1><p>简而言之，对于 io 密集的应用程序 比如 web 应用经常使用数据库访问，这类应用就比较适合使用异步编程的方式。多线程编程适合计算量密集的应用，比如视频图像处理，科学计算，能让没一个 cpu 核心起到最大的作用。</p>\n<h1 id=\"JavaScript-中的异步同步\"><a href=\"#JavaScript-中的异步同步\" class=\"headerlink\" title=\"JavaScript 中的异步同步\"></a>JavaScript 中的异步同步</h1><h2 id=\"回调函数\"><a href=\"#回调函数\" class=\"headerlink\" title=\"回调函数\"></a>回调函数</h2><h3 id=\"fetch\"><a href=\"#fetch\" class=\"headerlink\" title=\"fetch\"></a>fetch</h3><p>用来发起一个请求来获取服务器数据，用来动态的更新页面内容<br>链式调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://....&quot;</span>)</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(..)</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(..)</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(..)</span><br><span class=\"line\">    .<span class=\"title function_\">then</span>(..)</span><br><span class=\"line\">    .<span class=\"title function_\">catch</span>(..)</span><br><span class=\"line\">    .<span class=\"title function_\">finally</span>(..)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 异步函数 表示返回值为promise对象的函数</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// await 会等待Promise完成之后直接返回最终的结果（这个时候不需要使用then的链式调用了）</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://...&quot;</span>); <span class=\"comment\">// response 是服务器返回的响应数据</span></span><br><span class=\"line\">  <span class=\"comment\">// await看上去会暂停函数执行 在等待的过程中javascript还是可以进行其他的更新操作</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> json = <span class=\"keyword\">await</span> response.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>();</span><br><span class=\"line\">返回值为promise;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h3><p>await 只能在异步函数中有效，不能在普通函数中使用。</p>\n<ol>\n<li></li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 若代码是 这么调用,那么将会是执行完promiseA再执行promiseB</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promiseA = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://.../post/1&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promiseB = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://.../post/2&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 应该直接使用Promise.all(),修改后的执行效率会提升一倍</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promiseA = <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://.../post/1&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promiseB = <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://.../post/2&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [a, b] = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([promiseA, promiseB]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>再循环中执行异步操作<br>❌ 错误 👇</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不可以直接调用forEach或者map之类的操作，这里的foreach会立刻返回，不会暂停等到所有的异步操作都执行完毕</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].<span class=\"title function_\">forEach</span>(<span class=\"keyword\">async</span> (i) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">someAsyncOperation</span>();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;done&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>();</span><br></pre></td></tr></table></figure>\n\n<p>✔ 正确写法如下:↓</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">someAsyncOperation</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;done&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里的for循环依旧会等到所有的异步操作执行完成之后再向后执行</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> promises=[</span><br><span class=\"line\">        <span class=\"title function_\">someAsyncOperation</span>();</span><br><span class=\"line\">        <span class=\"title function_\">someAsyncOperation</span>();</span><br><span class=\"line\">        <span class=\"title function_\">someAsyncOperation</span>();</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  <span class=\"keyword\">for</span> <span class=\"keyword\">await</span> (<span class=\"keyword\">let</span> result <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ..</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;done&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">f</span>();</span><br></pre></td></tr></table></figure>\n\n<p>3.不能再全局函数中写 await 只能在异步函数中使用</p>\n",
            "tags": [
                "web",
                "javaScript"
            ]
        }
    ]
}